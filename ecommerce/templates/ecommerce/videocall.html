<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Video Call</title>
  <style>
    video { width: 45%; margin: 5px; border: 1px solid #ccc; }
    .video-container { position: relative; display: inline-block; }
    .icon {
      position: absolute;
      font-size: 24px;
      background: rgba(0,0,0,0.5);
      padding: 2px 5px;
      border-radius: 5px;
      display: none;
    }
    .mute { top: 10px; left: 10px; color: red; }
    .video-off { top: 10px; right: 10px; color: yellow; }
  </style>
</head>
<body>
  <h2>WebRTC Video Call</h2>

  <input id="userId" type="text" placeholder="Enter your ID"/>
  <button id="connectBtn">Connect</button>
  <button id="callBtn">Call</button>
  <button id="answerBtn" style="display:none;">Answer</button>
  <button id="hangupBtn">Hang Up</button>
  <button id="muteBtn">Mute</button>
  <button id="videoBtn">Turn Off Video</button>
  <br/><br/>

  <div class="video-container">
    <video id="localVideo" autoplay playsinline muted></video>
    <div id="localMuteIcon" class="icon mute">ğŸ”‡</div>
    <div id="localVideoOffIcon" class="icon video-off">ğŸ“·âŒ</div>
  </div>

  <div class="video-container">
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="remoteMuteIcon" class="icon mute">ğŸ”‡</div>
    <div id="remoteVideoOffIcon" class="icon video-off">ğŸ“·âŒ</div>
  </div>

  <script>
    const connectBtn = document.getElementById("connectBtn");
    const callBtn = document.getElementById("callBtn");
    const answerBtn = document.getElementById("answerBtn");
    const hangupBtn = document.getElementById("hangupBtn");
    const muteBtn = document.getElementById("muteBtn");
    const videoBtn = document.getElementById("videoBtn");

    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const localMuteIcon = document.getElementById("localMuteIcon");
    const remoteMuteIcon = document.getElementById("remoteMuteIcon");
    const localVideoOffIcon = document.getElementById("localVideoOffIcon");
    const remoteVideoOffIcon = document.getElementById("remoteVideoOffIcon");

    const username = "{{ request.user.username }}"; // from server template

    let localStream;
    let remoteStream;
    let peerConnection;
    let ws;
    let didIOffer = false;
    let incomingOffer = null;
    let pendingCandidates = [];
    let isMuted = false;
    let videoOff = false;

    const configuration = { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] };

    // ---------------------- WebSocket Connect ----------------------
    connectBtn.onclick = () => {
      const userId = document.getElementById("userId").value;
      if (!userId) return alert("Enter your user ID");

      ws = new WebSocket(`wss://318a38a52164.ngrok-free.app/ws/signaling/?user_id=${userId}`);

      ws.onopen = () => console.log("WebSocket connected!");

      ws.onmessage = async (e) => {
        const data = JSON.parse(e.data);

        if (data.type === "offer") {
          incomingOffer = data;
          answerBtn.style.display = "inline";
        }

        if (data.type === "answer") {
          if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            await drainPendingCandidates();
          }
        }

        if (data.type === "ice") {
          const candidate = new RTCIceCandidate(data.candidate);
          await handleIncomingIce(candidate);
        }

        if (data.type === "mute") {
          remoteMuteIcon.style.display = data.muted ? "block" : "none";
        }

        if (data.type === "video") {
          remoteVideoOffIcon.style.display = data.off ? "block" : "none";
        }

        if (data.type === "hangup") {
          alert(`${data.from} ended the call`);
          stopMedia();
          closeConnection();
        }
      };

      ws.onclose = () => console.log("WebSocket disconnected");
      ws.onerror = (err) => console.error("WebSocket error:", err);
    };

    // ---------------------- Media ----------------------
    async function fetchUserMedia() {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
    }

    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(configuration);
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      peerConnection.onicecandidate = (e) => {
        if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "ice", candidate: e.candidate, didIOffer }));
        }
      };

      peerConnection.ontrack = (e) => {
        e.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
      };
    }

    async function handleIncomingIce(candidate) {
      if (peerConnection && peerConnection.remoteDescription && peerConnection.remoteDescription.type) {
        try { await peerConnection.addIceCandidate(candidate); } 
        catch (err) { console.error(err); }
      } else {
        pendingCandidates.push(candidate);
      }
    }

    async function drainPendingCandidates() {
      if (!peerConnection || !peerConnection.remoteDescription || !peerConnection.remoteDescription.type) return;
      for (let candidate of pendingCandidates) {
        try { await peerConnection.addIceCandidate(candidate); } 
        catch(err) { console.error(err); }
      }
      pendingCandidates = [];
    }

    // ---------------------- Call ----------------------
    callBtn.onclick = async () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return alert("Connect first!");
      await fetchUserMedia();
      createPeerConnection();

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      didIOffer = true;

      ws.send(JSON.stringify({ type: "offer", offer, from: username }));
    };

    // ---------------------- Answer ----------------------
    answerBtn.onclick = async () => {
      if (!incomingOffer) return;

      answerBtn.style.display = "none";
      await fetchUserMedia();
      createPeerConnection();

      await peerConnection.setRemoteDescription(new RTCSessionDescription(incomingOffer.offer));
      await drainPendingCandidates();

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      ws.send(JSON.stringify({ type: "answer", answer, to: incomingOffer.from }));

      didIOffer = false;
      incomingOffer = null;
    };

    // ---------------------- Hang Up ----------------------
    hangupBtn.onclick = () => {
      stopMedia();
      closeConnection();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "hangup", from: username }));
      }
    };

    function stopMedia() {
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      if (remoteStream) remoteStream.getTracks().forEach(t => t.stop());
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
    }

    function closeConnection() {
      if (peerConnection) peerConnection.close();
      peerConnection = null;
      pendingCandidates = [];
      incomingOffer = null;
      didIOffer = false;
    }

    // ---------------------- Mute ----------------------
    muteBtn.onclick = () => {
      if (!localStream) return;

      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
      localMuteIcon.style.display = isMuted ? "block" : "none";
      muteBtn.textContent = isMuted ? "Unmute" : "Mute";

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "mute", muted: isMuted, from: username }));
      }
    };

    // ---------------------- Video On/Off ----------------------
    videoBtn.onclick = () => {
      if (!localStream) return;

      videoOff = !videoOff;
      localStream.getVideoTracks().forEach(track => track.enabled = !videoOff);
      localVideoOffIcon.style.display = videoOff ? "block" : "none";
      videoBtn.textContent = videoOff ? "Turn On Video" : "Turn Off Video";

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "video", off: videoOff, from: username }));
      }
    };
  </script>
</body>
</html>
